---
title: "클로저(closure)"
description: "This is the 클로저(closure) description for this page"
---

# 클로저(Closure)

제가 정의한 클로저란 중첩 함수인데 외부 렉시컬 환경의 식별자를 참조하고, 외부 함수보다 더 오래 유지되는 중첩함수입니다.

어떤 함수 A에서 선언한 변수 a를 참조하는 내부 함수 B를 외부로 전달할 경우 `A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상`입니다.

외부 함수보다 중첩함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부릅니다.

**렉시컬 스코프**

자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다. 이를 렉시컬 스코프(정적 스코프)라 합니다.

```jsx
const x = 1;

// 1
function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  };
  return inner;
}

const innerFunc = outer(); // 2
console.log("here"); // 3
innerFunc(); // 4

// output
// here
// 10
```

함수를 어디서 호출하든 상관없이 함수는 언제나 자신이 기억하는 상위 스코프의 식별자를 참조할 수 있으며 식별자에 바인딩된 값을 변경할 수도 있습니다.

2번이 평가되면서 outer함수가 실행이 됩니다. 그리고 3번으로 왔을 때 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거되지만 `outer 함수의 렉시컬 환경까지 소멸되는 것은 아닙니다.`

그 이유는 outer 함수의 렉시컬 환경은 inner 함수의 [[Environment]] 내부 슬롯에 의해 참조되고 있고 inner 함수는 전역 변수 innerFunc에 의해 참조되고 있으므로 가비지 컬렉션의 대상이 되지 않기 때문입니다.

외부 함수보다 더 오래 생존한 중첩 함수는 외부 함수의 생존 여부(실행 컨텍스트의 생존 여부)와 상관없이 자신이 정의된 위치에 의해 결정된 상위 스코프를 기억합니다. 이처럼 중첩 함수 inner의 내부에서는 상위 스코프를 참조할 수 있으므로 상위 스코프의 식별자를 참조할 수 있고 식별자의 값을 변경할 수도 있습니다.

자바스크립트의 모든 함수는 상위 스코프를 기억하므로 이론적으로 모든 함수는 클로저입니다. 그러나 보편적으로 `클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적입니다.`

클로저에 의해 참조되는 상위 스코프의 변수(x)를 자유 변수라고 부릅니다.
